# ------------------------------------------------------------------------------
#                     Author    : FIS - JPD
#                     Time-stamp: "2021-04-18 17:04:52 jpdur"
# ------------------------------------------------------------------------------

# -------------------------------------------------------------------------------
# Objective is to read the XL spreadsheet as generated by DIA and reformatted it 
# so that it can process in a similar way to the data provided by LDC 
# -------------------------------------------------------------------------------
# To be checked the situation with level 3 only .... => Not clear. likely some adjustment
# -------------------------------------------------------------------------------

# Convert csv files to xlsx from LDCCSVDownloads to LDCDownloads
param(
    [Parameter(Mandatory=$false)] [string] $Exec_Dir = [System.IO.Path]::GetDirectoryName($myInvocation.MyCommand.Definition),
    [Parameter(Mandatory=$false)] [string] $DestDirectory = "g:/Rainmaker/DIA2STG/G004", # Destination Directory if populated
    # [Parameter(Mandatory=$false)] [string] $FileName = "SaasCo-Ref.xlsx",
    [Parameter(Mandatory=$false)] [string] $FileName = "G004-Ref.xlsx",
    [Parameter(Mandatory=$false)] [string] $Prefix #Quick Fix for company name such as 004 - not to be used/knowm
)

# Create the Destination directory if necessary
New-Item -ItemType Directory -Force -Path $DestDirectory >>null

# Process all the data within 1 Worksheet
function ProcessWorksheet ($WorksheetName,$Hierarchy) {
    
    # 1st Part Read the 1st meanongful set of lines and extract the company Name 
    $Data = Import-Excel $Filename -WorksheetName $WorksheetName -StartRow 5 -EndRow 7 -StartCol 2 -HeaderName 'ColA','ColB'
    $Company = $Data[0].ColB
    # $Company

    # Extract the columns with all the different dates for which data is collected
    # The list of periods can thus be created
    $ListPeriods = Import-Excel $Filename -WorksheetName $WorksheetName -StartRow 10 -EndRow 12 -StartCol 6 -NoHeader
    # $ListPeriods 
    # $ListPeriods |Format-Table
    # $Period1 = $ListPeriods.P1
    # $Period1

    # Count the Nb of periods 
    $NbPeriods = ($ListPeriods | Get-Member -MemberType NoteProperty | Measure-Object).Count

    # Create the list of Headers in order to be able to read it
    # -------------------------------------------------------------
    # A bit manual but the only way to be sure that the Headers are in exactly the same order
    # especially in the case there is more than 10 columns 
    # -------------------------------------------------------------
    $ListHeaders =  'Level','Cat','Subcat1','Subcat2','Subcat3'
    for ($i=1 ; $i -le $NbPeriods ; $i++){
	$ListHeaders += "P"+$i
    }

    # Extract the key structure of data plus all the associated values
    $Structure = Import-Excel $Filename -WorksheetName $WorksheetName -StartRow 13 -StartCol 1 -EndCol (5+$NbPeriods)  -HeaderName $ListHeaders
    # $Structure

    # ----------------------------------------------------------------------
    # Pre-Treatment in order to sort out the specific handling of level 2
    # In that case the presentation is non standard
    # ----------------------------------------------------------------------
    foreach ($line in $Structure) {
	# The issue is specific to line where Level = 2 and Subcat2 is empty
	if (($line.Level -eq 2) -and ($line.Subcat2.length -eq 0)) {
	    # In that case 
	    $line.Subcat2 = $line.Subcat3
	    $line.Subcat3 = ""
	}
    }

    # Plug holes by Columns of structure on;y meaningful when the summaey lines 
    # have been removed
    $NbLines = $Structure.length
    for ($i=0;$i -lt $NbLines-1; $i++) {
	if ($Structure[$i].Cat.length -ne 0) {
	    $Structure[$i].Cat = ($Structure[$i].Cat).trim()
	}
	if ($Structure[$i+1].Cat.length -eq 0) {
	    $Structure[$i+1].Cat=$Structure[$i].Cat
	}
    }

    for ($i=0;$i -lt $NbLines-1; $i++) {
	if ($Structure[$i].Subcat1.length -ne 0) {
	    $Structure[$i].Subcat1 = ($Structure[$i].Subcat1).trim()
	}
	if ($Structure[$i+1].Subcat1.length -eq 0) {
	    $Structure[$i+1].Subcat1=$Structure[$i].Subcat1
	}
    }

    for ($i=0;$i -lt $NbLines-1; $i++) {
	if ($Structure[$i].Subcat2.length -ne 0) {
	    $Structure[$i].Subcat2 = ($Structure[$i].Subcat2).trim()
	}
	if ($Structure[$i+1].Subcat2.length -eq 0) {
	    $Structure[$i+1].Subcat2=$Structure[$i].Subcat2
	}
    }

    for ($i=0;$i -lt $NbLines-1; $i++) {
	if ($Structure[$i].Subcat3.length -ne 0) {
	    $Structure[$i].Subcat3 = ($Structure[$i].Subcat3).trim()
	}
	if ($Structure[$i+1].Subcat3.length -eq 0) {
	    $Structure[$i+1].Subcat3=$Structure[$i].Subcat3
	}
    }

    # Trim the last line 
    $Structure[$NbLines-1].Cat     = $Structure[$NbLines-1].Cat.    trim()
    $Structure[$NbLines-1].Subcat1 = $Structure[$NbLines-1].Subcat1.trim()
    $Structure[$NbLines-1].Subcat2 = $Structure[$NbLines-1].Subcat2.trim()
    $Structure[$NbLines-1].Subcat3 = $Structure[$NbLines-1].Subcat3.trim()

    # $Structure

    # Get rid of all the lines which are not to be kept
    $j=0
    $NewStructure = @()
    for ($i=0;$i -lt $NbLines-1; $i++) {
	if ($Structure[$i].Level -ge $Structure[$i+1].Level) {
	    $NewStructure+=$Structure[$i]
	}
    }

    # Last line is always kept 
    $NewStructure+=$Structure[$NbLines-1]

    # Get rid of all the extra items added based on the level
    foreach ($line in $NewStructure) {
	if ($line.Level -eq 1) {
	    $line.subcat2 = ""
	    $line.subcat3 = ""
	}
	if ($line.Level -eq 2) {
	    $line.subcat3 = ""
	}
    }

    # We modify the structure by removing the Level
    # $NewStructure = $NewStructure | Select-Object -Property * -ExcludeProperty Level

    # Check the final Result
    # $NewStructure | Format-Table
    # "NB Periods",$NbPeriods

    for ($i = 0 ; $i -lt $NbPeriods ; $i++) {

	# Determine the Period (P1 for the 1st perod cooresponding to index 0) 
	$Period = "P"+($i+1)

	# Create the list of Headers
	$ListHeaders  = 'Cat','Subcat1','Subcat2','Subcat3'
	$ListHeaders += $Period

	# Period to extract the data
	# $ListPeriods."$Period"

	# --------------------------------------------------------------------------
	# In case there is an extra column - skip that part of the loop 
	# It seems that in some cases an extra column is considered although empty 
	# hence the test below
	# --------------------------------------------------------------------------
	if (($ListPeriods."$Period")[0].length -eq 0) {
	    continue
	}

	# Determine the 2 letters code for scenario
	switch(($ListPeriods."$Period")[0]) {
	    'Actuals' {$Scenario = "AC"}
	    'Budget'  {$Scenario = "BU"}
	    'OBP'     {$Scenario = "OB"}
	}

	# Read the data corresponding to the period
	$Year = ($ListPeriods."$Period")[1].substring(0,4)
	$Date = [datetime]::ParseExact(($ListPeriods."$Period")[2],"M/dd/yyyy", $null)
	# Format the month so that with a leading zero if necessary
	$Month = '{0:d2}' -f $Date.Month
	
	# Create an XL spreadsheet using only the 1st set of values
	# and eliminate the Level Column  
	$Result1 = $NewStructure | Select-Object -Property $ListHeaders

	# Create the desired Filename following the standard convention
	# 006_011_PL_AC_2019_06_FIS_Data_Encoded_20210415_154654.xlsx
	# ----------------------------------------------------------------
	$FileName = "DIA_"+$Company+"_"+$Hierarchy+"_"+$Scenario+"_"+$Year+"_"+$Month+"_FIS_Data_Encoded"+(Get-Date).ToString("yyyyMMdd_hhmmss")+".xlsx"
	$FileName = $DestDirectory+"\"+$FileName

	# Save the result into an Excel Spreadsheet for review 
	$Result1 | Export-Excel -AutoSize -WorksheetName $WorksheetName $FileName
    }
}

# List of Worksheet name with Hierarchy shortname
$ListWorksheetName = @(
    [pscustomobject]@{WorksheetName="Income Statement";Hierarchy="PL"},
    [pscustomobject]@{WorksheetName="Balance Sheet"   ;Hierarchy="BS"},
    [pscustomobject]@{WorksheetName="Cashflows"       ;Hierarchy="CF"}
)

# # Process all the worksheets based on the list above
# foreach ($Sheet in $ListWorksheetName) {
#     ProcessWorksheet  -WorksheetName $Sheet.WorksheetName -Hierarchy $Sheet.Hierarchy
# }

# Test for cashflows
ProcessWorksheet  -WorksheetName "Income Statement" -Hierarchy "PL"
# ProcessWorksheet  -WorksheetName "Cashflows" -Hierarchy "CF"
